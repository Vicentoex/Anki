<!-- Back Template (Reverso) - Dise√±o Minimalista Optimizado -->
<div class="question-container">
  <div class="question-text">
    {{Anverso}}
  </div>
</div>

<div id="streak-container" class="streak-display"></div>

<div id="options-container-back" class="options-wrapper"></div>

<div id="result-message"></div>

<div class="answer-section">
  <span class="answer-label">Respuesta Correcta</span>
  <div id="correct-answer-display" class="correct-answer-text">{{Answer}}</div>
</div>

<div class="notes-section">
  <span class="notes-label">Notas de Estudio</span>
  <div class="notes-content">
    {{Notas}}
  </div>
</div>

<script>
(function() {
  // Bandera para evitar ejecuci√≥n m√∫ltiple
  let hasProcessed = false;
  
  // Misma funci√≥n para generar la clave √∫nica de la pregunta
  function generateQuestionKey(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return 'anki_q_' + Math.abs(hash);
  }
  
  const questionText = `{{Anverso}}`.trim();
  const questionKey = generateQuestionKey(questionText);
  
  // Claves √∫nicas para esta pregunta espec√≠fica
  const SHUFFLE_KEY = questionKey + '_shuffle';
  const SELECTION_KEY = questionKey + '_selection';
  const STREAK_KEY = 'anki_streak_count';
  const TOTAL_CORRECT_KEY = 'anki_total_correct';
  const TOTAL_ATTEMPTS_KEY = 'anki_total_attempts';
  
  // Funci√≥n para actualizar y mostrar estad√≠sticas
  function updateStats(isCorrect, hasSelection) {
    if (!hasSelection) return;
    
    let streak = parseInt(sessionStorage.getItem(STREAK_KEY) || '0');
    let totalCorrect = parseInt(sessionStorage.getItem(TOTAL_CORRECT_KEY) || '0');
    let totalAttempts = parseInt(sessionStorage.getItem(TOTAL_ATTEMPTS_KEY) || '0');
    
    totalAttempts++;
    
    if (isCorrect) {
      streak++;
      totalCorrect++;
    } else {
      streak = 0;
    }
    
    sessionStorage.setItem(STREAK_KEY, streak);
    sessionStorage.setItem(TOTAL_CORRECT_KEY, totalCorrect);
    sessionStorage.setItem(TOTAL_ATTEMPTS_KEY, totalAttempts);
    
    // Mostrar racha actual solo si es mayor a 2
    const streakContainer = document.getElementById('streak-container');
    if (streakContainer && streak > 2) {
      streakContainer.innerHTML = `
        <div class="streak-badge">
          <span class="streak-icon">üî•</span>
          <span class="streak-number">${streak}</span>
          <span class="streak-text">racha</span>
        </div>
      `;
      streakContainer.style.animation = 'fadeIn 0.3s ease';
    }
  }
  
  function showResults() {
    // Evitar ejecuci√≥n m√∫ltiple
    if (hasProcessed) return;
    hasProcessed = true;
    
    const correctAnswer = `{{Answer}}`.trim();
    const container = document.getElementById('options-container-back');
    const resultMessageEl = document.getElementById('result-message');
    const correctAnswerDisplayEl = document.getElementById('correct-answer-display');
    
    if (!container || !resultMessageEl || !correctAnswerDisplayEl) return;
    
    // Mostrar respuesta correcta
    correctAnswerDisplayEl.textContent = correctAnswer;
    
    // Obtener las opciones barajadas del sessionStorage
    let options;
    try {
      const shuffledData = sessionStorage.getItem(SHUFFLE_KEY);
      if (shuffledData) {
        options = JSON.parse(shuffledData);
      } else {
        options = [
          `{{Opci√≥n 1}}`.trim(),
          `{{Opci√≥n 2}}`.trim(),
          `{{Opci√≥n 3}}`.trim()
        ].filter(opt => opt !== '');
      }
    } catch (e) {
      console.error('Error al recuperar opciones:', e);
      options = [
        `{{Opci√≥n 1}}`.trim(),
        `{{Opci√≥n 2}}`.trim(),
        `{{Opci√≥n 3}}`.trim()
      ].filter(opt => opt !== '');
    }
    
    // Obtener la selecci√≥n del usuario
    const userChoice = sessionStorage.getItem(SELECTION_KEY);
    const hasSelection = !!userChoice;
    const isCorrect = hasSelection && userChoice === correctAnswer;
    
    // Actualizar estad√≠sticas
    updateStats(isCorrect, hasSelection);
    
    // Limpiar contenedor
    container.innerHTML = '';
    
    // Mostrar todas las opciones con estilos apropiados
    options.forEach((option) => {
      const div = document.createElement('div');
      div.className = 'option-result';
      
      const optionText = document.createElement('span');
      optionText.className = 'option-text-result';
      optionText.textContent = option;
      
      div.appendChild(optionText);
      
      // Aplicar estilos seg√∫n el estado de la opci√≥n
      if (option === correctAnswer) {
        div.classList.add('correct');
      } else if (hasSelection && option === userChoice) {
        div.classList.add('user-wrong');
      } else {
        div.classList.add('incorrect');
      }
      
      container.appendChild(div);
    });
    
    // Mostrar mensaje de resultado con emoticono
    if (!hasSelection) {
      resultMessageEl.textContent = '‚ö†Ô∏è No seleccionaste ninguna opci√≥n';
      resultMessageEl.className = 'warning';
      
    } else if (isCorrect) {
      // Mensajes variados con emoticonos
      const messages = [
        '‚úÖ ¬°Correcto!',
        'üéØ ¬°Excelente!',
        '‚ú® ¬°Muy bien!',
        'üëç ¬°Perfecto!'
      ];
      resultMessageEl.textContent = messages[Math.floor(Math.random() * messages.length)];
      resultMessageEl.className = 'success';
      
      // Vibraci√≥n de √©xito (m√≥viles)
      if (navigator.vibrate) {
        navigator.vibrate([30, 20, 30]);
      }
      
    } else {
      resultMessageEl.textContent = '‚ùå Incorrecto';
      resultMessageEl.className = 'error';
      
      // Vibraci√≥n de error (m√≥viles)
      if (navigator.vibrate) {
        navigator.vibrate(150);
      }
    }
    
    // Animaciones sutiles de entrada
    container.style.opacity = '0';
    container.style.transform = 'translateY(10px)';
    setTimeout(() => {
      container.style.transition = 'all 0.3s ease';
      container.style.opacity = '1';
      container.style.transform = 'translateY(0)';
    }, 0);
    
    resultMessageEl.style.animation = 'fadeIn 0.3s ease';
    document.querySelector('.answer-section').style.animation = 'fadeIn 0.3s ease 0.1s backwards';
    document.querySelector('.notes-section').style.animation = 'fadeIn 0.3s ease 0.2s backwards';
    
    // Limpiar sessionStorage para esta pregunta despu√©s de mostrar resultados
    setTimeout(function() {
      sessionStorage.removeItem(SHUFFLE_KEY);
      sessionStorage.removeItem(SELECTION_KEY);
    }, 100);
  }
  
  // Ejecutar inmediatamente
  showResults();
  
  // Asegurar que se ejecute incluso con diferentes timings
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', showResults);
  } else {
    setTimeout(showResults, 0);
  }
})();
</script>

<style>
/* Animaciones espec√≠ficas del reverso */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Ajustes espec√≠ficos para mantener consistencia */
.streak-display {
  animation: none;
}

.streak-badge .streak-icon {
  animation: flicker 1.5s ease-in-out infinite;
}

@keyframes flicker {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

/* Optimizaci√≥n para m√≥vil */
@media (max-width: 480px) {
  .streak-badge {
    padding: 4px 10px;
    font-size: 13px;
  }
  
  .streak-number {
    font-size: 14px;
  }
}
</style>