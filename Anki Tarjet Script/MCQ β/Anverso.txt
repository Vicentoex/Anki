<!-- Front Template (Anverso) - Compatible PC y Móvil - Con Teclado A/S/D -->
<div style="font-family:Arial; font-size:18px; margin-bottom:15px;">
  {{Anverso}}
</div>

<form id="quiz-front">
  <div id="options-container-front" style="margin-top:15px;">
    <!-- Las opciones se generarán dinámicamente -->
  </div>
</form>

<script>
(function() {
  // Generamos una clave única basada en el contenido de la pregunta
  // Esto asegura que cada pregunta tenga su propio espacio en sessionStorage
  function generateQuestionKey(content) {
    // Usamos un hash simple para crear una clave única
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return 'anki_q_' + Math.abs(hash);
  }
  
  const questionText = `{{Anverso}}`.trim();
  const questionKey = generateQuestionKey(questionText);
  
  // Claves únicas para esta pregunta específica
  const SHUFFLE_KEY = questionKey + '_shuffle';
  const SELECTION_KEY = questionKey + '_selection';
  
  // Array con las opciones originales
  const originalOptions = [
    `{{Opción 1}}`.trim(),
    `{{Opción 2}}`.trim(),
    `{{Opción 3}}`.trim()
  ].filter(opt => opt !== ''); // Filtramos opciones vacías
  
  // Fisher-Yates para barajar
  function shuffleArray(array) {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  
  // Función para seleccionar una opción por índice
  function selectOptionByIndex(index) {
    const container = document.getElementById('options-container-front');
    if (!container) return;
    
    const radios = container.querySelectorAll('input[type="radio"]');
    if (radios[index]) {
      radios[index].click();
      radios[index].focus();
    }
  }
  
  // Manejador de eventos del teclado
  function handleKeyPress(event) {
    // Solo procesar si no estamos en un campo de texto
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
      return;
    }
    
    const key = event.key.toLowerCase();
    
    switch(key) {
      case 'a':
        event.preventDefault();
        selectOptionByIndex(0); // Primera opción visible
        break;
      case 's':
        event.preventDefault();
        selectOptionByIndex(1); // Segunda opción visible
        break;
      case 'd':
        event.preventDefault();
        selectOptionByIndex(2); // Tercera opción visible
        break;
    }
  }
  
  function generateOptions() {
    const container = document.getElementById('options-container-front');
    if (!container || originalOptions.length === 0) return;
    
    // Limpiar selección previa de esta tarjeta específica
    sessionStorage.removeItem(SELECTION_KEY);
    
    // Barajar las opciones
    const shuffledOptions = shuffleArray(originalOptions);
    
    // Guardar el orden barajado para esta pregunta específica
    sessionStorage.setItem(SHUFFLE_KEY, JSON.stringify(shuffledOptions));
    
    // Limpiar contenedor
    container.innerHTML = '';
    
    // Crear los radio buttons
    shuffledOptions.forEach((option, index) => {
      const label = document.createElement('label');
      label.style.cssText = `
        display: block;
        margin-bottom: 10px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: relative;
      `;
      
      // Agregar indicador de tecla
      const keyIndicator = document.createElement('span');
      const keys = ['A', 'S', 'D'];
      keyIndicator.textContent = `[${keys[index]}]`;
      keyIndicator.style.cssText = `
        position: absolute;
        left: -30px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: bold;
        color: #666;
        font-size: 14px;
      `;
      
      // Efecto hover
      label.onmouseover = function() {
        this.style.backgroundColor = 'rgba(0,123,255,0.05)';
      };
      label.onmouseout = function() {
        if (!this.querySelector('input:checked')) {
          this.style.backgroundColor = 'transparent';
        }
      };
      
      const input = document.createElement('input');
      input.type = 'radio';
      input.name = 'mcq_choice';
      input.value = option;
      input.id = 'option_' + index;
      input.style.marginRight = '10px';
      
      // Guardar la selección cuando cambie
      input.addEventListener('change', function() {
        sessionStorage.setItem(SELECTION_KEY, option);
        // Actualizar estilos visuales
        container.querySelectorAll('label').forEach(lbl => {
          lbl.style.backgroundColor = 'transparent';
        });
        label.style.backgroundColor = 'rgba(0,123,255,0.1)';
      });
      
      label.appendChild(keyIndicator);
      label.appendChild(input);
      label.appendChild(document.createTextNode(option));
      container.appendChild(label);
    });
    
    // Ajustar el margen izquierdo del contenedor para acomodar los indicadores
    container.style.marginLeft = '40px';
  }
  
  // Función para verificar y regenerar si es necesario
  function checkAndGenerate() {
    const container = document.getElementById('options-container-front');
    if (container && !container.querySelector('input[type="radio"]')) {
      generateOptions();
    }
  }
  
  // Agregar listener de teclado
  document.addEventListener('keydown', handleKeyPress);
  
  // Generar opciones inicialmente
  generateOptions();
  
  // Verificación periódica para asegurar que las opciones estén presentes
  // Esto soluciona problemas de timing en diferentes plataformas
  let checkCount = 0;
  const checkInterval = setInterval(function() {
    checkCount++;
    checkAndGenerate();
    // Detenemos después de 10 verificaciones (1 segundo)
    if (checkCount >= 10) {
      clearInterval(checkInterval);
    }
  }, 100);
  
  // También verificar cuando el DOM esté completamente cargado
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', checkAndGenerate);
  }
  
  // Limpiar event listener cuando se cambie de tarjeta (para evitar duplicados)
  window.addEventListener('beforeunload', function() {
    document.removeEventListener('keydown', handleKeyPress);
  });
})();
</script>